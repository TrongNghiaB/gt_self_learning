### 🌱 The Essence of Functional Programming

- **Pure functions:** Each function always returns the same output for
  the same input and causes no side effects.\
- **Immutability:** Data is never modified; new values are created
  instead of changing existing ones.\
- **Function composition:** Programs are built by combining small,
  reusable functions.\
- **Declarative style:** You describe _what_ you want to compute, not
  _how_ step-by-step.\
- **No shared mutable state:** Avoids issues like race conditions and
  makes reasoning easier.\
- **Predictability & testability:** Because pure functions are
  deterministic, debugging and testing become simpler.

---

### ⚠️ Why Raising Errors Is Not Ideal in Functional Programming

- **Breaks purity:** Throwing an exception means a function may not
  always return a value → it's no longer pure.\
- **Interrupts flow:** Exceptions "jump out" of the normal function
  chain, breaking composition.\
- **Unpredictable behavior:** Harder to reason about and test since
  control flow depends on hidden side effects.\
- **Non-functional control flow:** Exceptions are imperative
  constructs (stateful jumps), not data transformations.\
- **Better alternative:** Represent errors as **data** (e.g.,
  `Option`, `Either`, `Result`) so functions always return a
  predictable value.\
- **Improves composability:** Functions can chain naturally with
  `map`, `flatMap`, etc., even when errors occur.\
- **Enhances reliability:** Programs can handle errors gracefully
  without crashing or breaking the call chain.

---

**In short:**\
\> Functional programming treats errors as _values_ to handle, not
_events_ that break execution.
